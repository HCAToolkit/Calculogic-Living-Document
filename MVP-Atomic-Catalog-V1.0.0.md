# MVP Atomic Catalog V1.0.0
Below is an MVP Atomic Catalog that’s just what you need to express an Enneagram project (HTML + CSS + TS/TSX), plus a separate list for exporter auto-writes, and then a final “extras / niceties” section.
1. Exporter auto-write layer (TSX / TS / CSS)
These are not atoms. The engine just does them automatically based on file type, so you never model them in the catalog.
build.tsx
Exporter auto-writes:
import React from "react";


import "./build.css";


Top-level component shell, e.g.:

 export function EnneagramBuild() {
  // generated from Build concern (ui.*, layout.*)
  return (
    <>
      {/* ... */}
    </>
  );
}


results.tsx
import React from "react";


import "./results.css";


Top-level component, e.g.:

 export function EnneagramResults(props: { results: EnneagramResultsModel }) {
  // generated from Results concern (result.*)
  return (
    <>
      {/* ... */}
    </>
  );
}


logic.ts
Module shell, e.g.:

 // generated from Logic concern (logic.*)
export const EnneagramLogic = {
  initState,
  evaluate,
  // ...
};


Type imports if needed (from knowledge.json schemas, etc.).


knowledge.json
Plain JSON file: no extra boilerplate, just the merged kb.* atoms.


CSS files
build.css / results.css:


File header comments (optional) like /* Generated by Calculogic – Build styles */


Nothing else is auto-magic; everything comes from style.* atoms.



2. MVP Atomic Catalog – Enneagram Core (v1.0)
This is the minimal set you need to represent:
The intro + questions UI


The CSS you showed


The Enneagram logic + rating engine


The structured results view


{
  "catalogVersion": "1.0.0",
  "atoms": [

    /* ───────────── UI (HTML primitives used) ───────────── */

    {
      "id": "ui.text",
      "kind": "ui",
      "props": {
        "value": { "type": "string" },
        "as": {
          "type": "enum",
          "values": ["p", "span", "h1", "h2", "h3", "h4", "h5", "h6"],
          "default": "p"
        }
      },
      "a11y": { "labelRequired": false }
    },

    {
      "id": "ui.form",
      "kind": "ui",
      "props": {
        "method": { "type": "enum", "values": ["get", "post"], "default": "get" },
        "action": { "type": "string" }
      },
      "events": ["onSubmit"],
      "a11y": {}
    },

    {
      "id": "ui.checkbox",
      "kind": "ui",
      "props": {
        "label": { "type": "string" },
        "checked": { "type": "boolean" },
        "valueBinding": { "type": "string" }  /* e.g. ratings["M1"] */
      },
      "events": ["onChange"],
      "a11y": { "labelRequired": true }
    },

    {
      "id": "ui.select",
      "kind": "ui",
      "props": {
        "label": { "type": "string" },
        "options": {
          "type": "list",
          "items": {
            "type": "object",
            "props": { "value": "string", "label": "string" }
          }
        },
        "valueBinding": { "type": "string" }
      },
      "events": ["onChange"],
      "a11y": { "labelRequired": true }
    },

    {
      "id": "ui.button",
      "kind": "ui",
      "props": {
        "label": { "type": "string" },
        "variant": {
          "type": "enum",
          "values": ["solid", "ghost", "link"],
          "default": "solid"
        }
      },
      "events": ["onClick"],
      "a11y": {}
    },

    {
      "id": "ui.details",
      "kind": "ui",
      "props": {
        "summary": { "type": "string" },
        "open": { "type": "boolean", "default": false }
      },
      "a11y": {}
    },

    /* ───────────── Layout (sections / containers) ───────────── */

    {
      "id": "layout.group",
      "kind": "layout",
      "props": {
        "as": {
          "type": "enum",
          "values": ["div", "section", "fieldset"],
          "default": "div"
        },
        "legend": { "type": "string" }
      }
    },

    {
      "id": "layout.stack",
      "kind": "layout",
      "props": {
        "direction": {
          "type": "enum",
          "values": ["row", "column"],
          "default": "column"
        },
        "gap": { "type": "number", "default": 8 },
        "align": {
          "type": "enum",
          "values": ["start", "center", "end", "stretch"],
          "default": "start"
        },
        "justify": {
          "type": "enum",
          "values": ["start", "center", "end", "between"],
          "default": "start"
        },
        "wrap": { "type": "boolean", "default": false }
      }
    },

    {
      "id": "layout.repeat",
      "kind": "layout",
      "props": {
        "from": { "type": "expression" },   /* e.g. kb.map('motivations').entries */
        "itemName": { "type": "string" }    /* e.g. "option" */
      }
    },

    /* ───────────── Style (CSS primitives actually needed) ───────────── */

    {
      "id": "style.rule",
      "kind": "style",
      "props": {
        "select": { "type": "selector" },
        "props": { "type": "object" }       /* { margin: "0", padding: "0", ... } */
      }
    },

    {
      "id": "style.flex",
      "kind": "style",
      "props": {
        "select": { "type": "selector" },
        "direction": {
          "type": "enum",
          "values": ["row", "column"],
          "default": "row"
        },
        "gap": { "type": "number" },
        "justify": { "type": "string" },  /* e.g. "space-between" */
        "align": { "type": "string" },    /* e.g. "center" */
        "wrap": { "type": "boolean" }
      }
    },

    /* (You *can* implement collapsible transitions with style.rule only;
       style.motion is nice-to-have and listed later.) */

    /* ───────────── Logic (Workflow – used by Enneagram) ───────────── */

    {
      "id": "logic.state",
      "kind": "logic",
      "props": {
        "name": { "type": "string" },       /* e.g. "ratings", "selectedCount" */
        "type": {
          "type": "enum",
          "values": ["number", "string", "boolean", "object"],
          "default": "object"
        },
        "initial": { "type": "any" }
      }
    },

    {
      "id": "logic.if",
      "kind": "logic",
      "props": {
        "cond": { "type": "expression" }    /* e.g. selectedCount["Motivations"] > 4 */
      }
    },

    {
      "id": "logic.compute",
      "kind": "logic",
      "props": {
        "expr": { "type": "expression" }    /* scoring, sorting, wings, etc. */
      }
    },

    {
      "id": "logic.on",
      "kind": "logic",
      "props": {
        "event": {
          "type": "enum",
          "values": ["onChange", "onClick", "onSubmit"],
          "default": "onClick"
        },
        "target": { "type": "ref" },        /* e.g. ref("calculate-button") */
        "do": { "type": "actionList" }      /* engine-specific: sequence of logic actions */
      }
    },

    {
      "id": "logic.validateGroup",
      "kind": "logic",
      "props": {
        "group": { "type": "ref" },         /* e.g. group of checkboxes */
        "rule": {
          "type": "enum",
          "values": ["maxSelected"],
          "default": "maxSelected"
        },
        "args": { "type": "object" }        /* { max: 4 } */
      }
    },

    /* ───────────── Knowledge (data tables + constants) ───────────── */

    {
      "id": "kb.const",
      "kind": "kb",
      "props": {
        "key": { "type": "string" },        /* e.g. "categories", "categoryNames" */
        "value": { "type": "any" }
      }
    },

    {
      "id": "kb.list",
      "kind": "kb",
      "props": {
        "key": { "type": "string" },
        "items": { "type": "array" }        /* e.g. ["M","F","D","W","S"] */
      }
    },

    {
      "id": "kb.map",
      "kind": "kb",
      "props": {
        "key": { "type": "string" },        /* "motivations", "fears", etc. */
        "entries": { "type": "object" }     /* M1..M9, F1..F9: description, type, function */
      }
    },

    /* ───────────── Results (output primitives actually used) ───────────── */

    {
      "id": "result.text",
      "kind": "result",
      "props": {
        "value": { "type": "expression" },  /* e.g. "Dominant: " + type + " (score …)" */
        "as": {
          "type": "enum",
          "values": ["p", "span", "h3"],
          "default": "p"
        }
      }
    },

    {
      "id": "result.list",
      "kind": "result",
      "props": {
        "from": { "type": "expression" },   /* e.g. enneagramTypeRatings, sortedJungianFunctions */
        "sortBy": { "type": "string" },     /* e.g. "rating" */
        "order": {
          "type": "enum",
          "values": ["asc", "desc"],
          "default": "desc"
        },
        "itemTemplate": {
          "type": "enum",
          "values": ["text", "score", "json"],
          "default": "score"
        }
      }
    }

  ]
}

That’s the true MVP: if you had only those atoms, you could implement:
The intro text


The full five-question Enneagram form (checkbox + rating select)


The logic for counting, rating, wings, sorting


The knowledge tables (M/F/D/W/S, types, functions)


The structured, collapsible results.



3. Extras / Niceties (can come later, or live at end of catalog)
These are the “nice-to-have” atoms you had before. They’re not exporter boilerplate; they’re just not strictly required for the Enneagram MVP:
Extra UI / Layout
ui.image – for logos, illustrations.


ui.link – for “learn more” links.


ui.icon – for icons in buttons or headings.


ui.progress – progress bar (e.g. “Question 3 of 5”).


layout.grid – responsive grids if you want fancier layouts.


Extra Style
style.var – design tokens (--color-primary, spacing scale).


style.query – container/media queries for responsive rules.


style.grid-template – CSS grid areas.


style.motion – animation/transition presets for collapsibles.


Extra Logic
logic.validate – field-level validation (required, range, pattern).


logic.showHide – imperatively show/hide elements outside <details>.


logic.repeat – logic-side loops if you want to explicitly model iteration.


logic.toggle – boolean toggling with side effects.


logic.delay – time-based flows.


logic.bind – linking computed expressions into specific props.


logic.route – multi-page routing within a project.


Extra Knowledge
kb.enum – named enumerations.


kb.schema – structured data models for stricter typing.


kb.ref – cross-config / cross-project references.


Meta / System
meta.comment – human comments per concern (super nice in exports).


meta.example – “here’s an example usage” fragments.


system.anchor – cross-concern linking (Build → Logic → Results).


system.debug – debug hooks (logs, probes).


system.doc-block – top-level documentation chunks in the project.


You can keep all of these in the catalog, but mentally treat them as:
Core / required: the MVP subset above.


Extended / optional: everything in this section, which you’ll “turn on” as Calculogic matures.


That way your living document stays clean: you know exactly which atoms are necessary to recreate the Enneagram test, which ones are future-power, and what the exporter will simply auto-write for you.

